#if canImport(AppKit)
import AppKit
import CoreText
import CoreGraphics
import SwiftUI

enum SynopsisPDFWriter {
    private static let pageSize = CGSize(width: 612, height: 792)
    private static let margin: CGFloat = 54
    private static var contentRect: CGRect { CGRect(x: margin, y: margin, width: pageSize.width - 2*margin, height: pageSize.height - 2*margin) }
    
    static func makePDF(
        title: String,
        dateLine: String,
        filters: String?,
        dateFilter: String?,
        body: String,
        posKeywords: [String],
        negKeywords: [String]
    ) -> Data? {
        let data = NSMutableData()
        guard let consumer = CGDataConsumer(data: data as CFMutableData) else { return nil }
        var mediaBox = CGRect(origin: .zero, size: pageSize)
        guard let ctx = CGContext(consumer: consumer, mediaBox: &mediaBox, nil) else { return nil }
        
        func attr(_ string: String, size: CGFloat, weight: NSFont.Weight = .regular, color: NSColor = .black, lineSpacing: CGFloat = 2) -> NSAttributedString {
            let p = NSMutableParagraphStyle(); p.lineSpacing = lineSpacing; p.paragraphSpacing = 6
            return NSAttributedString(string: string, attributes: [.font: NSFont.systemFont(ofSize: size, weight: weight), .foregroundColor: color, .paragraphStyle: p])
        }
        
        let doc = NSMutableAttributedString()
        doc.append(attr("\(title)\n", size: 24, weight: .bold))
        doc.append(attr(dateLine + "\n\n", size: 12))
        var chips: [String] = []
        if let f = filters, !f.isEmpty { chips.append("Filter: \(f)") }
        if let d = dateFilter, !d.isEmpty { chips.append("Date: \(d)") }
        if !chips.isEmpty { doc.append(attr(chips.joined(separator: "   ") + "\n\n", size: 11, weight: .semibold)) }
        doc.append(attr("Executive Summary\n", size: 18, weight: .semibold))
        doc.append(attr(body + "\n\n", size: 12, lineSpacing: 3))
        if !posKeywords.isEmpty || !negKeywords.isEmpty {
            doc.append(attr("Top Positive Keywords\n", size: 14, weight: .semibold))
            if !posKeywords.isEmpty { doc.append(attr("• " + posKeywords.prefix(10).joined(separator: "\n• ") + "\n\n", size: 12)) }
            doc.append(attr("Top Negative Keywords\n", size: 14, weight: .semibold))
            if !negKeywords.isEmpty { doc.append(attr("• " + negKeywords.prefix(10).joined(separator: "\n• ") + "\n\n", size: 12)) }
        }
        
        let framesetter = CTFramesetterCreateWithAttributedString(doc as CFAttributedString)
        var currentRange = CFRange(location: 0, length: 0)
        while currentRange.location < doc.length {
            ctx.beginPDFPage([kCGPDFContextMediaBox as String: mediaBox] as CFDictionary)
            ctx.setFillColor(NSColor.white.cgColor); ctx.fill(mediaBox)
            let path = CGMutablePath(); path.addRect(contentRect)
            let frame = CTFramesetterCreateFrame(framesetter, currentRange, path, nil)
            CTFrameDraw(frame, ctx)
            let vis = CTFrameGetVisibleStringRange(frame)
            if vis.length == 0 { ctx.endPDFPage(); break }
            currentRange.location += vis.length; currentRange.length = 0
            let footer = attr("Generated by Sentiment Analyzer", size: 10, color: .secondaryLabelColor)
            let footerLine = CTLineCreateWithAttributedString(footer)
            ctx.textPosition = CGPoint(x: contentRect.minX, y: margin - 18)
            CTLineDraw(footerLine, ctx)
            ctx.endPDFPage()
        }
        ctx.closePDF(); return data as Data
    }
}
#endif
